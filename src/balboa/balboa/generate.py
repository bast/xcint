def get_ijk_list(m):
    l = []
    for a in range(1, m + 2):
        for b in range(1, a + 1):
            i = m + 1 - a
            j = a - b
            k = b - 1
            l.append([i, j, k])
    return l


def test_get_ijk_list():
    assert get_ijk_list(3) == [
        [3, 0, 0],
        [2, 1, 0],
        [2, 0, 1],
        [1, 2, 0],
        [1, 1, 1],
        [1, 0, 2],
        [0, 3, 0],
        [0, 2, 1],
        [0, 1, 2],
        [0, 0, 3],
    ]


def print_line(exp, geo, m, r, suffix):

    _exp = exp[:]
    _exp[m] -= 1

    vec_r = 'buffer[OFFSET_{0:02d}_{1:02d}_{2:02d}_{3}{4}{5}]'.format(exp[0], exp[1], exp[2], geo[0], geo[1], geo[2])
    vec_p = r
    vec_a = 'buffer[OFFSET_{0:02d}_{1:02d}_{2:02d}_{3}{4}{5}]'.format(_exp[0], _exp[1], _exp[2], geo[0], geo[1], geo[2])

    if (geo[m] > 0):
        geo_right = geo[:]
        geo_right[m] -= 1
        vec_b = 'buffer[OFFSET_{0:02d}_{1:02d}_{2:02d}_{3}{4}{5}]'.format(_exp[0], _exp[1], _exp[2], geo_right[0], geo_right[1], geo_right[2])
        if geo[m] > 1:
            if suffix == 'block':
                return 'get_pa_plus_sb_block(&{0}, {1}, {2}.0, &{3}, &{4});'.format(vec_a, vec_p, geo[m], vec_b, vec_r)
            else:
                return 'get_pa_plus_sb(num_points_batch, &{0}, {1}, {2}.0, &{3}, &{4});'.format(vec_a, vec_p, geo[m], vec_b, vec_r)
        else:
            if suffix == 'block':
                return 'get_pa_plus_b_block(&{0}, {1}, &{2}, &{3});'.format(vec_a, vec_p, vec_b, vec_r)
            else:
                return 'get_pa_plus_b(num_points_batch, &{0}, {1}, &{2}, &{3});'.format(vec_a, vec_p, vec_b, vec_r)
    else:
        if suffix == 'block':
            return 'get_pa_block(&{0}, {1}, &{2});'.format(vec_a, vec_p, vec_r)
        else:
            return 'get_pa(num_points_batch, &{0}, {1}, &{2});'.format(vec_a, vec_p, vec_r)


def test_print_line():
    s = print_line([1, 1, 1], [1, 1, 1], 2, 'py', 'block')
    assert s == 'get_pa_plus_b_block(&buffer[OFFSET_01_01_00_111], py, &buffer[OFFSET_01_01_00_110], &buffer[OFFSET_01_01_01_111]);'


def get_offsets(max_l_value, ao_chunk_length, max_geo_diff_order):
    s = []
    s.append('#pragma once')
    s.append('')
    offset = 0
    for l in range(max_l_value + 1):
        for exp in get_ijk_list(l):
            for g in range(max_geo_diff_order + 1):
                for geo in get_ijk_list(g):
                    s.append('#define OFFSET_{0:02d}_{1:02d}_{2:02d}_{3}{4}{5} {6}'.format(exp[0], exp[1], exp[2], geo[0], geo[1], geo[2], offset))
                    offset += ao_chunk_length
    s.append('')
    s.append('#define BUFFER_LENGTH {0}'.format(offset))
    return '\n'.join(s)


def test_get_offsets():
    s = '''#pragma once

#define OFFSET_00_00_00_000 0
#define OFFSET_00_00_00_100 32
#define OFFSET_00_00_00_010 64
#define OFFSET_00_00_00_001 96
#define OFFSET_01_00_00_000 128
#define OFFSET_01_00_00_100 160
#define OFFSET_01_00_00_010 192
#define OFFSET_01_00_00_001 224
#define OFFSET_00_01_00_000 256
#define OFFSET_00_01_00_100 288
#define OFFSET_00_01_00_010 320
#define OFFSET_00_01_00_001 352
#define OFFSET_00_00_01_000 384
#define OFFSET_00_00_01_100 416
#define OFFSET_00_00_01_010 448
#define OFFSET_00_00_01_001 480

#define BUFFER_LENGTH 512'''
    assert get_offsets(1, 32, 1) == s


def write_routine(_maxg,
                  file_name,
                  max_l_value,
                  ao_chunk_length,
                  max_geo_diff_order,
                  d_geo_ijk_slice,
                  suffix):

    from cs_trans import get_cs_trans

    s = '''
//  this file is automatically generated by generate.py

#include <iostream>
#include <cstdlib>
#include <math.h>
#include <stdio.h>
#include <cstring>

#include "autogenerated.h"
#include "offsets.h"
#include "ao_vector.h"

{signature}
    )
{{
'''.format(signature=get_signature(_maxg, suffix))

    if _maxg > 0:
        for i in range(_maxg + 1):
            s += '    double fx_{0};\n'.format(i)
            s += '    double fy_{0};\n'.format(i)
            s += '    double fz_{0};\n'.format(i)

    s += '    double a;\n'
    s += '    double c;\n\n'

    if suffix == 'block':
        s += '        get_p2_block(shell_centers_coordinates,\n'
    else:
        s += '        get_p2(num_points_batch, shell_centers_coordinates,\n'
    s += '                     x_coordinates_bohr,\n'
    s += '                     y_coordinates_bohr,\n'
    s += '                     z_coordinates_bohr,\n'
    s += '                     px,\n'
    s += '                     py,\n'
    s += '                     pz,\n'
    s += '                     p2);\n\n'

    s += '        // screening\n'
    if suffix == 'block':
        s += '        if (not calculate_chunk_block(extent_squared, p2)) return;\n\n'
    else:
        s += '        if (not calculate_chunk(num_points_batch, extent_squared, p2)) return;\n\n'

    array = 'buffer[OFFSET_00_00_00_000]'
    if suffix == 'block':
        s += '        memset(&%s, 0, %i*sizeof(double));\n' % (array, ao_chunk_length)
    else:
        s += '        memset(&%s, 0, num_points_batch*sizeof(double));\n' % (array)
    for g in range(1, _maxg + 1):
        for geo in get_ijk_list(g):
            array = 'buffer[OFFSET_00_00_00_%i%i%i]' % (geo[0], geo[1], geo[2])
            if suffix == 'block':
                s += '        memset(&%s, 0, %i*sizeof(double));\n' % (array, ao_chunk_length)
            else:
                s += '        memset(&%s, 0, num_points_batch*sizeof(double));\n' % (array)

    if suffix == 'block':
        s += '''
            for (int i = 0; i < num_primitives; i++)
            {
                a = -primitive_exponents[i];
                c = contraction_coefficients[i];

                get_exp_block(p2, c, a, s);

                for (int k = 0; k < %i; k++)
                {
                    buffer[OFFSET_00_00_00_000 + k] += s[k];
                  \n''' % ao_chunk_length
    else:
        s += '''
            for (int i = 0; i < num_primitives; i++)
            {
                a = -primitive_exponents[i];
                c = contraction_coefficients[i];

                get_exp(num_points_batch, p2, c, a, s);

                for (int k = 0; k < num_points_batch; k++)
                {
                    buffer[OFFSET_00_00_00_000 + k] += s[k];
                  \n'''

    if (_maxg > 0):
        s += '''                fx_0 = 1.0;
                fy_0 = 1.0;
                fz_0 = 1.0;
                fx_1 = 2.0*a*px[k];
                fy_1 = 2.0*a*py[k];
                fz_1 = 2.0*a*pz[k];
                buffer[OFFSET_00_00_00_100 + k] += fx_1*s[k];
                buffer[OFFSET_00_00_00_010 + k] += fy_1*s[k];
                buffer[OFFSET_00_00_00_001 + k] += fz_1*s[k];
                  \n'''

    for g in range(2, _maxg + 1):
        s += '                fx_%i = fx_%i*fx_1 + %i.0*a*fx_%i;\n' % (int(g), int(g - 1), int(g - 1) * 2, int(g - 2))
        s += '                fy_%i = fy_%i*fy_1 + %i.0*a*fy_%i;\n' % (int(g), int(g - 1), int(g - 1) * 2, int(g - 2))
        s += '                fz_%i = fz_%i*fz_1 + %i.0*a*fz_%i;\n' % (int(g), int(g - 1), int(g - 1) * 2, int(g - 2))
        for geo in get_ijk_list(g):
            s += '                buffer[OFFSET_00_00_00_%i%i%i + k] += fx_%i*fy_%i*fz_%i*s[k];\n' % (geo[0], geo[1], geo[2], geo[0], geo[1], geo[2])
    s += '            }\n'
    s += '        }\n'

    cs = get_cs_trans(max_l_value)

    for l in range(max_l_value + 1):
        s += '\n        if (shell_l_quantum_numbers == ' + '%i)\n' % l
        s += '        {\n'
        if l < 2:
            c = 0
            for exp in get_ijk_list(l):
                for _s in range(len(cs[l][c])):
                    f = cs[l][c][_s]
                    if abs(f) > 0.0:
                        for g in range(_maxg + 1):
                            for geo in get_ijk_list(g):
                                s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                                if suffix == 'block':
                                    s += '            memcpy(&ao_000[%i*xoff + %i*num_points], &buffer[OFFSET_%02d_%02d_%02d_%s], %i*sizeof(double));\n' % (d_geo_ijk_slice[tuple(geo)], _s, exp[0], exp[1], exp[2], s_geo, ao_chunk_length)
                                else:
                                    s += '            memcpy(&ao_000[%i*xoff + %i*num_points], &buffer[OFFSET_%02d_%02d_%02d_%s], num_points_batch*sizeof(double));\n' % (d_geo_ijk_slice[tuple(geo)], _s, exp[0], exp[1], exp[2], s_geo)
                c += 1
        else:
            s += '            if (is_spherical)\n'
            s += '            {\n'
            c = 0
            for exp in get_ijk_list(l):
                for _s in range(len(cs[l][c])):
                    f = cs[l][c][_s]
                    if abs(f) > 0.0:
                        for g in range(_maxg + 1):
                            for geo in get_ijk_list(g):
                                s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                                if suffix == 'block':
                                    s += '                vec_daxpy_block(%20.16e, &buffer[OFFSET_%02d_%02d_%02d_%s], &ao_000[%i*xoff + %i*num_points]);\n' % (f, exp[0], exp[1], exp[2], s_geo, d_geo_ijk_slice[tuple(geo)], _s)
                                else:
                                    s += '                vec_daxpy(num_points_batch, %20.16e, &buffer[OFFSET_%02d_%02d_%02d_%s], &ao_000[%i*xoff + %i*num_points]);\n' % (f, exp[0], exp[1], exp[2], s_geo, d_geo_ijk_slice[tuple(geo)], _s)
                c += 1
            s += '            }\n'
            s += '            else\n'
            s += '            {\n'
            _s = 0
            for exp in get_ijk_list(l):
                for g in range(_maxg + 1):
                    for geo in get_ijk_list(g):
                        s_geo = '%i%i%i' % (geo[0], geo[1], geo[2])
                        if suffix == 'block':
                            s += '                memcpy(&ao_000[%i*xoff + %i*num_points], &buffer[OFFSET_%02d_%02d_%02d_%s], %i*sizeof(double));\n' % (d_geo_ijk_slice[tuple(geo)], _s, exp[0], exp[1], exp[2], s_geo, ao_chunk_length)
                        else:
                            s += '                memcpy(&ao_000[%i*xoff + %i*num_points], &buffer[OFFSET_%02d_%02d_%02d_%s], num_points_batch*sizeof(double));\n' % (d_geo_ijk_slice[tuple(geo)], _s, exp[0], exp[1], exp[2], s_geo)
                _s += 1
            s += '            }\n'
        s += '            return;\n'
        s += '        }\n'
        s += '        else\n'
        s += '        {\n'
        if l + 1 < max_l_value + 1:
            for exp in get_ijk_list(l + 1):
                for g in range(_maxg + 1):
                    for geo in get_ijk_list(g):
                        if exp[0] > 0:
                            s += print_line(exp, geo, 0, 'px', suffix) + '\n'
                        else:
                            if exp[1] > 0:
                                s += print_line(exp, geo, 1, 'py', suffix) + '\n'
                            else:
                                if exp[2] > 0:
                                    s += print_line(exp, geo, 2, 'pz', suffix) + '\n'
        else:
            s += '             std::cout << "error: order too high";\n'
            s += '             exit(1);\n'
        s += '        }\n'
    s += '\n}\n'

    with open(file_name, 'w') as f:
        f.write(s)


def get_signature(g, suffix):

    s = []

    s.append('void get_ao_g{0}_{1}('.format(g, suffix))
    s.append('    const int    shell_l_quantum_numbers,')
    s.append('    const int    num_primitives,')
    s.append('    const bool   is_spherical,')
    s.append('    const double primitive_exponents[],')
    s.append('    const double contraction_coefficients[],')
    s.append('    const int    num_points,')
    if suffix == 'explicit':
        s.append('    const int    num_points_batch,')
    s.append('    const int    xoff,')
    s.append('          double s[],')
    s.append('          double buffer[],')
    s.append('    const double shell_centers_coordinates[],')
    s.append('    const double extent_squared,')
    s.append('    const double x_coordinates_bohr[],')
    s.append('    const double y_coordinates_bohr[],')
    s.append('    const double z_coordinates_bohr[],')
    s.append('          double px[],')
    s.append('          double py[],')
    s.append('          double pz[],')
    s.append('          double p2[],')
    s.append('          double ao_000[]')

    return '\n'.join(s)


def get_header(max_geo_diff_order):

    s = []

    s.append('#pragma once')
    s.append('')

    for g in range(max_geo_diff_order + 1):
        s.append(get_signature(g, 'block'))
        s.append('    );\n')
        s.append(get_signature(g, 'explicit'))
        s.append('    );\n')
        s.append('')

    return '\n'.join(s)


def cleanup(s, pad):

    _s = s

    _s = _s.replace('[]', '')
    _s = _s.replace('const int    ', '')
    _s = _s.replace('const double ', '')
    _s = _s.replace('      double ', '')
    _s = _s.replace('const bool   ', '')

    _s_pad = []
    for line in _s.split('\n'):
        _s_pad.append(pad * ' ' + line)

    return '\n'.join(_s_pad)


def generate_dispatcher(output_directory, max_geo_diff_order):
    import os

    signature = '''const int    max_geo_order,
    const int    shell_l_quantum_number,
    const int    num_primitives,
    const bool   is_spherical,
    const double primitive_exponents[],
    const double contraction_coefficients[],
    const int    num_points,
    const int    num_points_batch,
    const int    xoff,
          double s[],
          double buffer[],
    const double shell_centers_coordinates[],
    const double extent_squared,
    const double x_coordinates_bohr[],
    const double y_coordinates_bohr[],
    const double z_coordinates_bohr[],
          double px[],
          double py[],
          double pz[],
          double p2[],
          double ao_000[]'''

    with open(os.path.join(output_directory, 'ao_dispatch.h'), 'w') as f:
        f.write('''#pragma once
void ao_dispatch(
    {0}
    );'''.format(signature))

    with open(os.path.join(output_directory, 'ao_dispatch.cpp'), 'w') as f:
        f.write('''
#include <iostream>
#include <stdlib.h>  /* exit */


#include "autogenerated.h"
#include "balboa_parameters.h"


void ao_dispatch(
    {0}
    )'''.format(signature))

        f.write('''
{
    if (num_points_batch < AO_CHUNK_LENGTH)
    {
        switch (max_geo_order)
        {
''')

        for g in range(max_geo_diff_order + 1):
            f.write('''            case {order}:
                get_ao_g{order}_explicit(    {signature}
                    );
                break;
'''.format(order=g, signature=cleanup(signature, 16).replace('max_geo_order,', '')))

        f.write('''            default:
                std::cout << "ERROR: get_ao order too high";
                exit(1);
                break;
        }
    }
    else
    {
        switch (max_geo_order)
        {
''')

        for g in range(max_geo_diff_order + 1):
            f.write('''            case {order}:
                get_ao_g{order}_block(    {signature}
                    );
                break;
'''.format(order=g, signature=cleanup(signature, 16).replace('max_geo_order,', '').replace('num_points_batch,', '')))

        f.write('''            default:
                std::cout << "ERROR: get_ao order too high";
                exit(1);
                break;
        }
    }
}
''')


def main(output_directory, max_l_value, ao_chunk_length, max_geo_diff_order):
    import os

    d_geo_ijk_slice = {}
    j = 0
    for _g in range(max_geo_diff_order + 1):
        for geo in get_ijk_list(_g):
            d_geo_ijk_slice[tuple(geo)] = j
            j += 1

    generate_dispatcher(output_directory, max_geo_diff_order)

    with open(os.path.join(output_directory, 'offsets.h'), 'w') as f:
        f.write(get_offsets(max_l_value, ao_chunk_length, max_geo_diff_order))

    for suffix in ['block', 'explicit']:
        for g in range(max_geo_diff_order + 1):
            write_routine(g,
                          os.path.join(output_directory, 'autogenerated_{0}_{1}.cpp'.format(g, suffix)),
                          max_l_value,
                          ao_chunk_length,
                          max_geo_diff_order,
                          d_geo_ijk_slice,
                          suffix)

    with open(os.path.join(output_directory, 'autogenerated.h'), 'w') as f:
        f.write(get_header(max_geo_diff_order))


if __name__ == '__main__':
    import sys
    main(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]), int(sys.argv[4]))
